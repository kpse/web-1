package models.V3

import anorm.SqlParser._
import anorm._
import models.School
import play.Logger
import play.api.Play.current
import play.api.db.DB
import play.api.libs.json.Json

case class SchoolClassV3(id: Option[Long], school_id: Long, class_id: Option[Int], name: String, managers: Option[List[Long]] = None, updated_at: Option[Long] = None) {
  def idExists = DB.withConnection {
    implicit c =>
      id match {
        case Some(i) =>
          SQL("select count(1) from classinfo where school_id={kg} and class_id = {classId} and uid <> {uid} and status=1").on(
            'kg -> school_id,
            'classId -> class_id,
            'uid -> id
          ).as(get[Long]("count(1)") single) > 0
        case None =>
          SQL("select count(1) from classinfo where school_id={kg} and class_id = {id} and status=1").on(
            'kg -> school_id,
            'id -> class_id
          ).as(get[Long]("count(1)") single) > 0
      }
  }

  def classNameExists(): Boolean = DB.withConnection {
    implicit c =>
      class_id match {
        case Some(x) =>
          SQL("select count(1) from classinfo where school_id={kg} and class_id <> {id} and class_name={name} and status=1").on(
            'kg -> school_id,
            'id -> x,
            'name -> name
          ).as(get[Long]("count(1)") single) > 0
        case None =>
          SQL("select count(1) from classinfo where school_id={kg} and class_name={name} and status=1").on(
            'kg -> school_id,
            'name -> name
          ).as(get[Long]("count(1)") single) > 0
      }
  }

  def create: Option[SchoolClassV3] = DB.withTransaction {
    implicit c =>
      try {
        val autoGeneratedClassId: Int = class_id.getOrElse(models.School.generateClassId(school_id))
        val insert: Option[Long] = SQL("insert into classinfo (school_id, class_id, class_name, update_at) " +
          "values ({kg}, {class_id}, {name}, {time})")
          .on('kg -> school_id.toString,
            'class_id -> autoGeneratedClassId,
            'name -> name,
            'time -> System.currentTimeMillis).executeInsert()

        insert match {
          case Some(i) =>
            updateManagers(autoGeneratedClassId)
            c.commit()
            SchoolClassV3.show(school_id, i)
          case None =>
            c.rollback()
            Logger.warn("new classinfo insertion failed.")
            None
        }
      }
      catch {
        case t: Throwable => c.rollback()
          Logger.warn(t.getLocalizedMessage)
          None
      }
  }

  def updateManagers(classId: Int) = DB.withConnection {
    implicit c =>
      if (managers.nonEmpty) {
        SQL("delete from privilege where school_id={kg} and subordinate={class}")
          .on('kg -> school_id.toString, 'class -> classId.toString).execute()
      }

      managers.getOrElse(List()).map (EmployeeV3.show(school_id, _)) filter (_.nonEmpty) map {
        manager =>
          SQL("insert into privilege (school_id, employee_id, `group`, subordinate, promoter, update_at) values " +
            "({kg},{id},{group},{subordinate},{promoter},{time})").on(
            'kg -> school_id.toString,
            'id -> manager.get.basic.id,
            'group -> "teacher",
            'promoter -> "admin",
            'subordinate -> classId.toString,
            'time -> System.currentTimeMillis
          ).executeInsert()
      }
  }

  def update: Option[SchoolClassV3] = DB.withTransaction {
    implicit c =>
      try {
        SQL("update classinfo set class_name={name}, update_at={time}, status=1 " +
          "where uid={id} and school_id={kg}")
          .on(
            'kg -> school_id.toString,
            'id -> id,
            'name -> name,
            'time -> System.currentTimeMillis).executeUpdate()

        id flatMap {
          case i =>
            class_id foreach updateManagers
            c.commit()
            SchoolClassV3.show(school_id, i)
        }
      }
      catch {
        case t: Throwable => c.rollback()
          Logger.warn(t.getLocalizedMessage)
          None
      }
  }
}

object SchoolClassV3 {
  implicit val readSchoolClassV3 = Json.reads[SchoolClassV3]
  implicit val writeSchoolClassV3 = Json.writes[SchoolClassV3]

  def show(kg: Long, id: Long) = DB.withConnection {
    implicit c =>
      SQL("select * from classinfo where uid={uid} and status=1")
        .on('uid -> id).as(simple singleOpt)
  }

  val simple = {
    get[Long]("uid") ~
      get[Int]("class_id") ~
      get[String]("school_id") ~
      get[String]("class_name") ~
      get[Long]("update_at") map {
      case uid ~ classId ~ schoolId ~ name ~ updatedAt =>
        val managers: List[Long] = School.getClassManagers(schoolId.toLong, classId).filter(_.uid.nonEmpty).map(_.uid.get)
        SchoolClassV3(Some(uid), schoolId.toLong, Some(classId), name, Some(managers), Some(updatedAt))
    }
  }
}
